// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const server = require("./app");

function spyOn(obj, methodName, newFunction) {
  const originalMethod = obj[methodName];
  obj[methodName] = newFunction;
  return {
    mockRestore: () => {
      obj[methodName] = originalMethod;
    }
  };
}

const mockListen = (port, callback) => {
  if (callback) {
    callback();
  }
  return {
    mockImplementation: (newImpl) => mockListen
  };
};

describe('Server Listen Method', () => {
  let consoleSpy;
  let mockServer;
  const PORT = 3000;

  // Mock the server's listen method before each test
  beforeEach(() => {
    consoleSpy = spyOn(console, 'log', () => {});
    mockServer = {
      listen: mockListen
    };
    server.listen = mockServer.listen;
  });

  // Clean up after each test
  afterEach(() => {
    consoleSpy.mockRestore();
  });

  test('Server starts successfully on the given port', () => {
    server.listen(PORT, null);

    expect(mockServer.listen).toHaveBeenCalledWith(PORT, expect.any(Function));
    expect(consoleSpy).toHaveBeenCalledWith(`Server Started. Server listening to port ${PORT}`);
  });

  test('Error is logged if server fails to start', () => {
    const errorMessage = 'Error starting server';
    mockServer.listen = (port, callback) => {
      if (callback) {
        callback(new Error(errorMessage));
      }
    };

    server.listen(PORT, null);

    expect(mockServer.listen).toHaveBeenCalledWith(PORT, expect.any(Function));
    expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining(errorMessage));
  });
});

