// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const { unblockUser } = require('./admin');
const userModel = require('../models/user');
const httpMocks = require('node-mocks-http');

// Mock module before the tests
jest.mock('../models/user');

let req, res, next;

describe('unblockUser', () => {
  beforeEach(() => {
    req = httpMocks.createRequest();
    res = httpMocks.createResponse();
    next = jest.fn();
  });

  test('should unblock the user and return success message if permissions granted', async () => {
    req.user = { username: 'testAdmin' };
    req.body = { _id: 'userId' };
    userModel.findOneAndUpdate.mockResolvedValue(true);

    await unblockUser(req, res, next);

    expect(res.statusCode).toBe(200);
    expect(res._getData()).toEqual({
      success: true,
      message: "Account has been unblocked"
    });
  });

  test('should return 401 if user is not authenticated', async () => {
    req.user = null;

    await unblockUser(req, res, next);

    expect(res.statusCode).toBe(401);
    expect(res._getData()).toEqual({
      success: false,
      message: "Permissions not granted!"
    });
  });

  test('should handle errors during unblocking the user', async () => {
    req.user = { username: 'testAdmin' };
    req.body = { _id: 'userId' };
    const fakeError = new Error('Fake error');
    userModel.findOneAndUpdate.mockRejectedValue(fakeError);

    await unblockUser(req, res, next);

    expect(res.statusCode).toBe(500);
    expect(res._getData()).toEqual({
      success: false,
      message: "Unable to unblock account"
    });
  });
});


