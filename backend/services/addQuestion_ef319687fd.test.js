// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const subjectModel = require('../models/subject');
const questionModel = require('../models/question');
const httpMocks = require('node-mocks-http');
const { addQuestion } = require('./question');

jest.mock('../models/subject');
jest.mock('../models/question');

describe('addQuestion Method', () => {
  let req, res, next;

  beforeEach(() => {
    req = httpMocks.createRequest();
    res = httpMocks.createResponse();
    next = jest.fn();
    req.user = { _id: 'user-id-1', usertype: 'TEACHER' };
    req.body = {
      body: 'What is 2 + 2?',
      options: ['1', '2', '3', '4'],
      answer: '4',
      marks: 1,
      subject: 'valid-subject-id'
    };
    subjectModel.findOne.mockResolvedValue({ _id: 'valid-subject-id', status: true });
    questionModel.prototype.save.mockResolvedValue({ _id: 'question-id-1' });
    req.check = jest.fn();
    req.validationErrors = jest.fn().mockReturnValue(null);
  });

  test('should create a question for a teacher', async () => {
    await addQuestion(req, res, next);

    expect(res.statusCode).toBe(200);
    expect(res._getJSONData()).toEqual({
      success: true,
      message: 'Question created successfully!'
    });
  });

  test('should reject creation for a non-teacher user', async () => {
    req.user.usertype = 'STUDENT';

    await addQuestion(req, res, next);

    expect(res.statusCode).toBe(401);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: "Permissions not granted!"
    });
  });

  test('should reject creation with invalid inputs', async () => {
    req.validationErrors.mockReturnValue([{ msg: 'Invalid inputs' }]);

    await addQuestion(req, res, next);

    expect(res.statusCode).toBe(200);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: 'Invalid inputs',
      errors: [{ msg: 'Invalid inputs' }]
    });
  });

  test('should reject creation with non-matching answer and options', async () => {
    req.body.answer = 'Option not in list';

    await addQuestion(req, res, next);

    expect(res.statusCode).toBe(200);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: 'Invalid inputs',
      error: 'Answer is not in list of options'
    });
  });

  test('should handle an error when saving a question', async () => {
    questionModel.prototype.save.mockRejectedValue(new Error('Unable to add question'));

    await addQuestion(req, res, next);

    expect(res.statusCode).toBe(500);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: "Unable to add question"
    });
  });

  test('should reject creation if subject is not found', async () => {
    subjectModel.findOne.mockResolvedValue(null);

    await addQuestion(req, res, next);

    expect(res.statusCode).toBe(200);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: 'Subject not found'
    });
  });
});

