// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const { addSubject } = require('./admin');
const httpMocks = require('node-mocks-http');
const subjectModel = require('../models/subject');

jest.mock('../models/subject');

describe('Admin - Add Subject', () => {
    let req, res, next;

    beforeEach(() => {
        req = httpMocks.createRequest({
            method: 'POST',
            url: '/subject/add',
            body: {
                name: 'Mathematics'
            },
            user: {
                _id: 'userId'
            }
        });
        res = httpMocks.createResponse();
        next = jest.fn();
    });

    test('should create a new subject if it does not exist', async () => {
        subjectModel.findOne.mockResolvedValue(null);
        subjectModel.prototype.save = jest.fn().mockResolvedValue(true);

        await addSubject(req, res, next);
        expect(res.statusCode).toBe(200);
        expect(res._getData()).toHaveProperty('success', true);
        expect(res._getData()).toHaveProperty('message', 'Subject created successfully!');
    });

    test('should not create a subject if it already exists', async () => {
        subjectModel.findOne.mockResolvedValue({
            name: 'Mathematics'
        });

        await addSubject(req, res, next);
        expect(res.statusCode).toBe(200);
        expect(res._getData()).toHaveProperty('success', false);
        expect(res._getData()).toHaveProperty('message', 'Subject already exists!');
    });

    test('should return an error if no user is provided', async () => {
        const newReq = httpMocks.createRequest({
            method: 'POST',
            url: '/subject/add',
            body: {
                name: 'Mathematics'
            }
        });

        await addSubject(newReq, res, next);
        expect(res.statusCode).toBe(401);
        expect(res._getData()).toHaveProperty('success', false);
        expect(res._getData()).toHaveProperty('message', 'Permissions not granted!');
    });

    test('should return an error for invalid input', async () => {
        req.body.name = '';

        await addSubject(req, res, next);
        expect(res.statusCode).toBe(422);
        expect(res._getData()).toHaveProperty('success', false);
        expect(res._getData()).toHaveProperty('message', 'Invalid inputs');
    });

    test('should handle database errors when saving a new subject', async () => {
        subjectModel.findOne.mockResolvedValue(null);
        subjectModel.prototype.save = jest.fn().mockRejectedValue(new Error('Database error'));

        await addSubject(req, res, next);
        expect(res.statusCode).toBe(500);
        expect(res._getData()).toHaveProperty('success', false);
        expect(res._getData()).toHaveProperty('message', 'Unable to add Subject');
    });

    afterEach(() => {
        jest.resetAllMocks();
    });
});

