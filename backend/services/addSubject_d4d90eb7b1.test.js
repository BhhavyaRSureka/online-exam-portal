// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const admin = require('./admin'); // Corrected import method
const httpMocks = require('node-mocks-http');
const SubjectModel = require('../models/subject');

// jest is assumed to be imported correctly in a testing environment
describe('addSubject', () => {
  let req, res, next;
  
  beforeEach(() => {
    req = httpMocks.createRequest();
    res = httpMocks.createResponse();
    next = jest.fn();
    req.user = { _id: 'user123' };
    req.body = {};
    SubjectModel.findOne = jest.fn();
    SubjectModel.prototype.save = jest.fn().mockResolvedValue({});
  });

  test('should successfully add a new subject', async () => {
    req.body.name = 'Math';
    req.check = jest.fn();
    req.validationErrors = jest.fn().mockReturnValue(null);
    SubjectModel.findOne.mockResolvedValue(null);

    await admin.addSubject(req, res, next);

    expect(res._getData()).toEqual({
      success: true,
      message: 'Subject created successfully!'
    });
    expect(res.statusCode).toBe(200);
  });

  test('should return 401 if the user is not logged in', async () => {
    req.user = null;

    await admin.addSubject(req, res, next);

    expect(res._getData()).toEqual({
      success: false,
      message: "Permissions not granted!"
    });
    expect(res.statusCode).toBe(401);
  });

  test('should handle invalid subject name', async () => {
    req.body.name = '';
    req.check = jest.fn();
    req.validationErrors = jest.fn().mockReturnValue(['Invalid name']);

    await admin.addSubject(req, res, next);

    expect(res._getData()).toEqual({
      success: false,
      message: 'Invalid inputs',
      errors: ['Invalid name']
    });
    expect(res.statusCode).toBe(200);
  });

  test('should not add a subject if it already exists', async () => {
    req.body.name = 'Science';
    req.check = jest.fn();
    req.validationErrors = jest.fn().mockReturnValue(null);
    SubjectModel.findOne.mockResolvedValue({ _id: 'existing123', name: 'Science' });

    await admin.addSubject(req, res, next);

    expect(res._getData()).toEqual({
      success: false,
      message: 'Subject is already exists!'
    });
    expect(res.statusCode).toBe(200);
  });

  test('should handle save errors', async () => {
    req.body.name = 'English';
    req.check = jest.fn();
    req.validationErrors = jest.fn().mockReturnValue(null);
    SubjectModel.findOne.mockResolvedValue(null);
    SubjectModel.prototype.save = jest.fn().mockRejectedValue(new Error('Save Error'));

    await admin.addSubject(req, res, next);

    expect(res._getData()).toEqual({
      success: false,
      message: "Unable to add Subject"
    });
    expect(res.statusCode).toBe(500);
  });

  afterEach(() => {
    jest.resetAllMocks();
  });
});

