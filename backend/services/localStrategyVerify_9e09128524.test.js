// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const JwtStrategy = require('passport-jwt').Strategy;
const ExtractJwt = require('passport-jwt').ExtractJwt;

const bcrypt = require('bcrypt');
const saltRounds = 10;

const config = require('config');

const userModel = require('../models/user');
const adminModel = require('../models/admin');

const localStrategyVerify = require('./passportconf').localStrategyVerify;

jest.mock('bcrypt');
jest.mock('../models/user');

describe('Local Strategy Verification', () => {
  let mockUser;

  beforeAll(() => {
    // Set up any global configuration you need before tests run.
  });

  beforeEach(() => {
    // Set up any preconditions for individual tests.
    mockUser = {
      email: 'test@example.com',
      password: 'hashed_password',
      status: true
    };
  });

  afterAll(() => {
    // Clean up any global configurations or asynchronous tasks.
  });

  afterEach(() => {
    // Clean up after individual tests.
    jest.clearAllMocks();
  });

  test('should return the user when email and password match', async () => {
    userModel.findOne.mockImplementation((query, callback) => callback(null, mockUser));
    bcrypt.compare.mockResolvedValue(true);

    const req = {};
    const done = jest.fn();

    await localStrategyVerify(req, mockUser.email, 'password', done);

    expect(userModel.findOne).toHaveBeenCalledWith({ email: mockUser.email }, expect.any(Function));
    expect(bcrypt.compare).toHaveBeenCalledWith('password', mockUser.password);
    expect(done).toHaveBeenCalledWith(null, mockUser, { success: true, message: 'logged in successfully' });
  });

  test('should return an error message if email is not registered', async () => {
    userModel.findOne.mockImplementation((query, callback) => callback(null, null));

    const req = {};
    const done = jest.fn();

    await localStrategyVerify(req, 'nonexistent@example.com', 'password', done);

    expect(userModel.findOne).toHaveBeenCalled();
    expect(done).toHaveBeenCalledWith(null, false, { success: false, message: 'email is not registered' });
  });

  test('should return an error message if the account is blocked', async () => {
    mockUser.status = false;
  
    userModel.findOne.mockImplementation((query, callback) => callback(null, mockUser));

    const req = {};
    const done = jest.fn();

    await localStrategyVerify(req, mockUser.email, 'password', done);

    expect(userModel.findOne).toHaveBeenCalled();
    expect(done).toHaveBeenCalledWith(null, false, { success: false, message: 'your account is blocked' });
  });

  test('should return an error message if the password is invalid', async () => {
    userModel.findOne.mockImplementation((query, callback) => callback(null, mockUser));
    bcrypt.compare.mockResolvedValue(false);

    const req = {};
    const done = jest.fn();

    await localStrategyVerify(req, mockUser.email, 'wrong_password', done);

    expect(userModel.findOne).toHaveBeenCalledWith({ email: mockUser.email }, expect.any(Function));
    expect(bcrypt.compare).toHaveBeenCalledWith('wrong_password', mockUser.password);
    expect(done).toHaveBeenCalledWith(null, false, { success: false, message: 'invalid password' });
  });

  test('should handle server errors during user lookup', async () => {
    userModel.findOne.mockImplementation((query, callback) => callback(new Error('Server error'), null));

    const req = {};
    const done = jest.fn();

    await localStrategyVerify(req, mockUser.email, 'password', done);

    expect(userModel.findOne).toHaveBeenCalled();
    expect(done).toHaveBeenCalledWith(new Error('Server error'), false, { success: false, message: 'server error' });
  });
});

