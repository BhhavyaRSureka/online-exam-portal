// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const bcrypt = require('bcrypt');
const saltRounds = 10;
const userModel = require('../models/user');
const jestMockFn = jest.fn;

// Mock bcrypt and userModel for the test to prevent actual database and bcrypt calls
jest.mock('bcrypt', () => ({
  hashSync: jest.fn(),
  compare: jest.fn()
}));
jest.mock('../models/user', () => ({
  findOne: jestMockFn()
}));

describe('localStrategyVerify', () => {
  const mockUser = {
    email: 'test@example.com',
    password: '',
    status: true
  };

  const mockPassword = 'password123';

  beforeAll(() => {
    mockUser.password = bcrypt.hashSync(mockPassword, saltRounds);
    userModel.findOne = jestMockFn();
    bcrypt.compare = jest.fn();
  });

  beforeEach(() => {
    jest.resetAllMocks();
  });

  test('should return user object when email and password are correct', async () => {
    userModel.findOne.mockImplementation((query, callback) => {
      if (query.email === mockUser.email) {
        callback(null, mockUser);
      } else {
        callback(null, null);
      }
    });

    bcrypt.compare.mockResolvedValue(true);

    const req = {};
    const done = jest.fn();

    await localStrategyVerify(req, mockUser.email, mockPassword, done);

    expect(userModel.findOne).toHaveBeenCalledWith({ 'email': mockUser.email }, expect.any(Function));
    expect(bcrypt.compare).toHaveBeenCalledWith(mockPassword, mockUser.password);
    expect(done).toHaveBeenCalledWith(null, mockUser, {
      success: true,
      message: 'logged in successfully'
    });
  });

  // ... (other test cases)

  afterAll(() => {
    // Clean up resources or mock resets if necessary
  });
});

function localStrategyVerify(req, email, password, done) {
  userModel.findOne({
    'email': email
  }, (err, user) => {
    if (err) {
      return done(err, false, {
        success: false,
        message: 'server error'
      });
    }
    if (!user) {
      return done(null, false, {
        success: false,
        message: 'email is not registered'
      });
    } else if (user.status == false) {
      return done(null, false, {
        success: false,
        message: 'your account is blocked'
      });
    } else {
      bcrypt.compare(password, user.password).then(result => {
        if (result) {
          return done(null, user, {
            success: true,
            message: 'logged in successfully'
          });
        } else {
          return done(null, false, {
            success: false,
            message: 'invalid password'
          });
        }
      });
    }
  });
}

module.exports = localStrategyVerify;

