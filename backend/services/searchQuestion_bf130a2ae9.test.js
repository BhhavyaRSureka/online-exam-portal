// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const request = require('supertest');
const express = require('express');
const bodyParser = require('body-parser');
const { check, validationResult } = require('express-validator');
const jest = require('jest');
var subjectModel = require('../models/subject');
var questionModel = require('../models/question');

const app = express();
app.use(bodyParser.json());

app.post('/searchQuestion',
  check('query').notEmpty().withMessage('Empty Query'),
  (req, res, next) => {
    var creator = req.user || null;
    if (creator == null || req.user.usertype != 'TEACHER') {
      return res.status(401).json({
        success: false,
        message: "Permissions not granted!"
      });
    }

    var errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.json({
        success: false,
        message: 'Invalid Inputs',
        errors: errors.array()
      });
    } else {
      questionModel.find({
        body: new RegExp(req.body.query, 'i')
      }).limit(20).then(questions => {
        let result = questions.map(que => ({
          _id: que._id,
          body: que.body,
          status: que.status
        }));
        res.json({
          success: true,
          list: result
        });
      }).catch(err => {
        res.status(500).json({
          success: false,
          message: "error"
        });
      });
    }
  });

// Jest test suite
describe('searchQuestion API endpoint', () => {
  let mockRequest, mockResponse, mockUser;

  beforeEach(() => {
    mockRequest = {};
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis()
    };
    mockUser = { usertype: 'TEACHER' };
    jest.clearAllMocks();

    subjectModel.find = jest.fn();
    questionModel.find = jest.fn();
  });

  test('Unauthorized request should return 401', async () => {
    const response = await request(app)
      .post('/searchQuestion')
      .send({ query: 'example' });

    expect(response.status).toEqual(401);
    expect(response.body.success).toBeFalsy();
    expect(response.body.message).toEqual('Permissions not granted!');
  });

  test('Empty query should return an error', async () => {
    const response = await request(app)
      .post('/searchQuestion')
      .send({ query: '' })
      .set('user', mockUser);

    expect(response.status).toEqual(200);
    expect(response.body.success).toBeFalsy();
    expect(response.body.message).toEqual('Invalid Inputs');
    expect(response.body.errors).toContainEqual({ msg: 'Empty Query', param: 'query', location: 'body' });
  });

  test('Successful search should return results', async () => {
    const questions = [
      { _id: '1', body: 'Question 1', status: 'active' },
      { _id: '2', body: 'Question 2', status: 'inactive' }
    ];

    questionModel.find.mockResolvedValue(questions);

    const response = await request(app)
      .post('/searchQuestion')
      .send({ query: 'Question' })
      .set('user', mockUser);

    expect(response.status).toEqual(200);
    expect(response.body.success).toBeTruthy();
    expect(response.body.list).toHaveLength(2);
    expect(response.body.list[0]._id).toEqual('1');
    expect(response.body.list[1].body).toContain('Question 2');
  });

  test('Database errors should be handled', async () => {
    const errorMessage = 'Database error';
    questionModel.find.mockRejectedValue(new Error(errorMessage));

    const response = await request(app)
      .post('/searchQuestion')
      .send({ query: 'Question' })
      .set('user', mockUser);

    expect(response.status).toEqual(500);
    expect(response.body.success).toBeFalsy();
    expect(response.body.message).toEqual('error');
  });
});

