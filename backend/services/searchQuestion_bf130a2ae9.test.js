// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const { createRequest, createResponse } = require('node-mocks-http');
const { searchQuestion } = require('../question');
const subjectModel = require('../models/subject');
const questionModel = require('../models/question');
const { beforeEach, describe, expect, jest, test } = require('@jest/globals');

describe('searchQuestion', () => {
  let req, res, next;

  beforeEach(() => {
    req = createRequest();
    res = createResponse();
    next = jest.fn();
    req.user = { usertype: 'TEACHER' };
    req.body = { query: 'test' };
    req.check = jest.fn().mockReturnValue(req);
    req.validationErrors = jest.fn().mockReturnValue(null);
  });

  test('should require a user to be authenticated as TEACHER', () => {
    req.user = null; // User is not authenticated

    searchQuestion(req, res, next);

    expect(res._getStatusCode()).toBe(401);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: "Permissions not granted!"
    });
  });

  test('should respond with status 401 if the authenticated user is not a TEACHER', () => {
    req.user.usertype = 'STUDENT';

    searchQuestion(req, res, next);

    expect(res._getStatusCode()).toBe(401);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: "Permissions not granted!"
    });
  });

  test('should check for empty query and return validation errors', () => {
    req.body.query = ''; // Empty query
    req.validationErrors = jest.fn().mockReturnValue([{ msg: 'Empty Query' }]); // Simulate validation error

    searchQuestion(req, res, next);

    expect(req.check).toHaveBeenCalledWith('query', 'Empty Query');
    expect(res._getJSONData()).toEqual({
      success: false,
      message: 'Invalid Inputs',
      errors: [{ msg: 'Empty Query' }]
    });
  });

  test('should return a list of questions matching the query', async () => {
    const mockQuestions = [
      { _id: '1', body: 'test body 1', status: 'active' },
      { _id: '2', body: 'test body 2', status: 'inactive' }
    ];
    questionModel.find = jest.fn().mockResolvedValue(mockQuestions);

    await searchQuestion(req, res, next);

    expect(res._getStatusCode()).toBe(200);
    expect(res._getJSONData()).toEqual({
      success: true,
      list: mockQuestions.map(q => ({
        _id: q._id,
        body: q.body,
        status: q.status
      }))
    });
  });

  test('should handle errors during search and return status 500', async () => {
    questionModel.find = jest.fn().mockRejectedValue(new Error('Search failed'));

    await searchQuestion(req, res, next);

    expect(res._getStatusCode()).toBe(500);
    expect(res._getJSONData()).toEqual({
      success: false,
      message: "error"
    });
  });
});

