// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
import { getDashboardCount } from './admin'; // Assuming getDashboardCount is exported from admin.js
import mongoose from 'mongoose';
import * as dbHandler from './test_db_handler'; // A module for in-memory database handling

// Mocking models and request/response objects
jest.mock('../models/subject');
jest.mock('../models/user');
import * as subjectModel from '../models/subject';
import * as userModel from '../models/user';

const req = {}; // Mocked request object
let res; // Mocked response object
beforeEach(() => {
  res = {
    json: jest.fn(),
    status: jest.fn(() => res),
  };
});

describe('getDashboardCount', () => {
  beforeAll(async () => {
    await dbHandler.connect(); // Connecting to in-memory database
  });

  afterEach(async () => {
    jest.clearAllMocks();
  });

  afterAll(async () => {
    await dbHandler.closeDatabase(); // Closing the in-memory database
  });

  test('should return counts of active and blocked entities successfully', async () => {
    subjectModel.aggregate.mockResolvedValue([
      { _id: true, count: 5 },
      { _id: false, count: 3 },
    ]);
    userModel.aggregate.mockResolvedValueOnce([
      { _id: true, count: 7 },
      { _id: false, count: 2 },
    ]);
    userModel.aggregate.mockResolvedValueOnce([
      { _id: true, count: 10 },
      { _id: false, count: 4 },
    ]);

    await getDashboardCount(req, res);

    expect(res.json).toHaveBeenCalledWith({
      success: true,
      activeStudent: 10,
      activeSubject: 5,
      activeTeacher: 7,
      blockedStudent: 4,
      blockedSubject: 3,
      blockedTeacher: 2,
    });
  });

  test('should handle errors when fetching subject counts', async () => {
    const errorMessage = { message: 'Internal Server Error' };
    subjectModel.aggregate.mockRejectedValue(errorMessage);

    await getDashboardCount(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: 'Internal Server Error',
    });
  });

  test('should handle errors when fetching teacher counts', async () => {
    subjectModel.aggregate.mockResolvedValue([]);
    userModel.aggregate.mockRejectedValueOnce(new Error('Internal Server Error'));

    await getDashboardCount(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: 'Internal Server Error',
    });
  });

  test('should handle errors when fetching student counts', async () => {
    subjectModel.aggregate.mockResolvedValue([]);
    userModel.aggregate.mockResolvedValueOnce([]); // Assuming teachers are fetched successfully
    userModel.aggregate.mockRejectedValueOnce(new Error('Internal Server Error'));

    await getDashboardCount(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: 'Internal Server Error',
    });
  });
});

