// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
jest.mock('../models/user');
jest.mock('../models/subject');
jest.mock('../models/admin');
jest.mock('../services/tool', () => ({
    hashPassword: jest.fn()
}));

const userModel = require('../models/user');
const subjectModel = require('../models/subject');
const { hashPassword } = require('../services/tool');
const { getDashboardCount } = require('./admin');

describe('Dashboard Counts', () => {
    const mockSubjects = [{ _id: true, count: 10 }, { _id: false, count: 2 }];
    const mockTeachers = [{ _id: true, count: 5 }, { _id: false, count: 1 }];
    const mockStudents = [{ _id: true, count: 20 }, { _id: false, count: 3 }];

    let req, res;

    beforeEach(() => {
        req = {};
        res = {
            json: jest.fn(),
            status: jest.fn().mockReturnThis()
        };
        subjectModel.aggregate.mockResolvedValue(mockSubjects);
        userModel.aggregate.mockImplementation(query => {
            if (query[0].$match.usertype === "TEACHER") {
                return Promise.resolve(mockTeachers);
            } else if (query[0].$match.usertype === "STUDENT") {
                return Promise.resolve(mockStudents);
            }
            return Promise.reject();
        });
    });

    test('should correctly calculate dashboard counts', async () => {
        await getDashboardCount(req, res);

        expect(res.json).toHaveBeenCalledWith({
            success: true,
            activeStudent: 20,
            activeSubject: 10,
            activeTeacher: 5,
            blockedStudent: 3,
            blockedSubject: 2,
            blockedTeacher: 1
        });
    });

    test('should return 500 error if subjectModel fails', async () => {
        subjectModel.aggregate.mockRejectedValue(new Error('Internal Server Error'));

        await getDashboardCount(req, res);

        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.json).toHaveBeenCalledWith({
            success: false,
            message: 'Internal Server Error'
        });
    });

    test('should return 500 error if userModel for TEACHER fails', async () => {
        userModel.aggregate.mockImplementation(query => {
            if (query[0].$match.usertype === "TEACHER") {
                return Promise.reject(new Error('Internal Server Error'));
            }
            return Promise.resolve(mockStudents);
        });

        await getDashboardCount(req, res);

        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.json).toHaveBeenCalledWith({
            success: false,
            message: 'Internal Server Error'
        });
    });

    test('should return 500 error if userModel for STUDENT fails', async () => {
        userModel.aggregate.mockImplementation(query => {
            if (query[0].$match.usertype === "STUDENT") {
                return Promise.reject(new Error('Internal Server Error'));
            }
            return Promise.resolve(mockTeachers);
        });

        await getDashboardCount(req, res);

        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.json).toHaveBeenCalledWith({
            success: false,
            message: 'Internal Server Error'
        });
    });
});

