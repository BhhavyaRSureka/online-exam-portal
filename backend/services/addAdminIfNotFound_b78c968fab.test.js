// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const userModel = require('../models/user');
const subjectModel = require('../models/subject');
const tool = require('./tool');
const adminModel = require('../models/admin');
const { hashPassword } = require('../services/tool');

describe('addAdminIfNotFound function', () => {
  const mockFindOne = jest.fn(); // Mocking 'findOne' method of adminModel
  const mockSave = jest.fn(); // Mock implementation for 'save' method
  const mockHashPassword = jest.fn(); // Mocking 'hashPassword' method
  
  // Saving the original implementations
  const originalFindOne = adminModel.findOne;
  const originalSave = adminModel.prototype.save;
  const originalHashPassword = tool.hashPassword;
  const originalConsoleLog = console.log;

  let consoleOutput = []; // To capture console.log outputs
  const mockedLog = output => consoleOutput.push(output);
  
  beforeAll(() => {
    // Mocking the methods
    adminModel.findOne = mockFindOne;
    adminModel.prototype.save = mockSave;
    tool.hashPassword = mockHashPassword;

    // Capture console logs
    console.log = mockedLog;
  });

  afterEach(() => {
    consoleOutput = []; // Clear the console output
    mockFindOne.mockClear();
    mockHashPassword.mockClear();
    mockSave.mockClear();
  });

  afterAll(() => {
    // Restoring the original implementations
    adminModel.findOne = originalFindOne;
    adminModel.prototype.save = originalSave;
    tool.hashPassword = originalHashPassword;
    console.log = originalConsoleLog;
  });

  test('should log "Admin user found" if admin already exists', async () => {
    // Mock findOne to simulate existing admin
    mockFindOne.mockResolvedValue({ username: 'sysadmin' });

    await require('./admin').addAdminIfNotFound();

    expect(mockFindOne).toHaveBeenCalledWith({ 'username': 'sysadmin' });
    expect(consoleOutput).toContain("Admin user found");
    expect(mockHashPassword).not.toHaveBeenCalled();
    expect(mockSave).not.toHaveBeenCalled();
  });

  test('should log "Admin added successfully !!" if admin does not exist', async () => {
    // Mock findOne to simulate no admin
    mockFindOne.mockResolvedValue(null);
    // Mock hashPassword to return a hash
    mockHashPassword.mockResolvedValue('hashed_password');

    await require('./admin').addAdminIfNotFound();

    expect(mockFindOne).toHaveBeenCalled();
    expect(mockHashPassword).toHaveBeenCalledWith('systemadmin');
    expect(mockSave).toHaveBeenCalled();
    expect(consoleOutput).toContain("Admin added successfully !!");
  });
  
  test('should handle error if findOne fails', async () => {
    // Mock findOne to simulate an error
    mockFindOne.mockRejectedValue(new Error('Find One Failed'));

    await require('./admin').addAdminIfNotFound();

    expect(mockFindOne).toHaveBeenCalled();
    // There should be some error logging or error handling here,
    // as per the actual implementation the test might need to change
  });

  test('should handle error if hashPassword fails', async () => {
    // Mock findOne to simulate no admin
    mockFindOne.mockResolvedValue(null);
    // Mock hashPassword to simulate an error
    mockHashPassword.mockRejectedValue(new Error('Hash Password Failed'));

    await require('./admin').addAdminIfNotFound();

    expect(mockFindOne).toHaveBeenCalled();
    expect(mockHashPassword).toHaveBeenCalledWith('systemadmin');
    expect(mockSave).not.toHaveBeenCalled();
    // There should be some error logging or error handling here,
    // as per the actual implementation the test might need to change
  });
});

