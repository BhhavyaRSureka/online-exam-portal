// ********RoostGPT********
// Test generated by RoostGPT for test NodeTest using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const request = require('supertest');
const express = require('express');
const bodyParser = require('body-parser');
const passport = require('passport');
const jwt = require('jsonwebtoken');
const config = require('config');
const { userLogin } = require('./login');

jest.mock('passport', () => {
  const originalModule = jest.requireActual('passport');
  return {
    ...originalModule,
    authenticate: jest.fn(),
  };
});
jest.mock('jsonwebtoken', () => {
  const originalModule = jest.requireActual('jsonwebtoken');
  return {
    ...originalModule,
    sign: jest.fn(),
  };
});

const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.post('/login', userLogin);

describe('User Login', () => {
  let user;
  let token;

  beforeAll(() => {
    // Mock passport authentication to avoid actual Passport strategy usage
    passport.authenticate.mockImplementation((strategy, options, callback) => (req, res, next) => {
      if (req.body.email === 'valid@example.com' && req.body.password === 'validPassword'){
        callback(null, {
          _id: '123456',
          username: 'ValidUser',
          usertype: 'Admin',
          email: 'valid@example.com',
        }, null);
      } else if (req.body.email === 'invalid@example.com') {
        callback(null, false, { message: 'Incorrect email or password.' });
      } else {
        callback(new Error('An error occurred'));
      }
    });
    
    // Spy on jwt.sign to ensure a token is created
    token = 'fake-token';
    jwt.sign.mockReturnValue(token);
  });

  afterEach(() => {
    // Reset mock for passport authentication and jwt sign
    passport.authenticate.mockReset();
    jwt.sign.mockReset();
  });

  afterAll(() => {
    jest.clearAllMocks();
  });

  test('should login a valid user', async () => {
    const response = await request(app)
      .post('/login')
      .send({ email: 'valid@example.com', password: 'validPassword' });

    expect(response.statusCode).toBe(200);
    expect(response.body).toEqual({
      success: true,
      message: 'login successful',
      user: {
        username: 'ValidUser',
        type: 'Admin',
        _id: '123456',
        email: 'valid@example.com'
      },
      token: token
    });
    expect(passport.authenticate).toHaveBeenCalledTimes(1);
    expect(jwt.sign).toHaveBeenCalledTimes(1);
  });

  test('should reject an invalid user', async () => {
    const response = await request(app)
      .post('/login')
      .send({ email: 'invalid@example.com', password: 'wrongPassword' });

    expect(response.statusCode).toBe(200);
    expect(response.body).toEqual({
      success: false,
      message: 'Incorrect email or password.'
    });
    expect(passport.authenticate).toHaveBeenCalledTimes(1);
    expect(jwt.sign).not.toHaveBeenCalled();
  });

  test('should return error for invalid email format', async () => {
    const response = await request(app)
      .post('/login')
      .send({ email: 'not-an-email', password: 'validPassword' });

    expect(response.statusCode).toBe(200);
    expect(response.body).toHaveProperty('success', false);
    expect(response.body).toHaveProperty('message', 'Invalid inputs');
    expect(response.body.errors).toEqual([
      { location: 'body', param: 'email', value: 'not-an-email', msg: 'Invalid email address' }
    ]);
  });

  test('should return error for password that is too short', async () => {
    const response = await request(app)
      .post('/login')
      .send({ email: 'valid@example.com', password: '123' });

    expect(response.statusCode).toBe(200);
    expect(response.body).toHaveProperty('success', false);
    expect(response.body).toHaveProperty('message', 'Invalid inputs');
    expect(response.body.errors).toEqual([
      {
        location: 'body',
        param: 'password',
        value: '123',
        msg: 'Password is too short'
      }
    ]);
  });

  test('should handle server error during login process', async () => {
    const response = await request(app)
      .post('/login')
      .send({ email: 'error@example.com', password: 'validPassword' });

    expect(response.statusCode).toBe(500);
    expect(response.body).toEqual({
      success: false,
      message: 'An error occurred'
    });
    expect(passport.authenticate).toHaveBeenCalledTimes(1);
    expect(jwt.sign).not.toHaveBeenCalled();
  });
});

